
# =====================
# Compression & Archiving
# =====================
compress() { tar -czf "${1%/}.tar.gz" "${1%/}"; }


# =====================
# Disk & Drive Utilities
# =====================
iso2sd() {
  if [ $# -ne 2 ]; then
    echo "Usage: iso2sd <input_file> <output_device>"
    echo "Example: iso2sd ~/Downloads/ubuntu-25.04-desktop-amd64.iso /dev/sda"
    echo -e "\nAvailable SD cards:"
    lsblk -d -o NAME | grep -E '^sd[a-z]' | awk '{print "/dev/"$1}'
  else
    sudo dd bs=4M status=progress oflag=sync if="$1" of="$2"
    sudo eject $2
  fi
}

format-drive() {
  if [ $# -ne 2 ]; then
    echo "Usage: format-drive <device> <name>"
    echo "Example: format-drive /dev/sda 'My Stuff'"
    echo -e "\nAvailable drives:"
    lsblk -d -o NAME -n | awk '{print "/dev/"$1}'
  else
    echo "WARNING: This will completely erase all data on $1 and label it '$2'."
    read -rp "Are you sure you want to continue? (y/N): " confirm

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
      sudo wipefs -a "$1"
      sudo dd if=/dev/zero of="$1" bs=1M count=100 status=progress
      sudo parted -s "$1" mklabel gpt
      sudo parted -s "$1" mkpart primary 1MiB 100%

      partition="$([[ $1 == *"nvme"* ]] && echo "${1}p1" || echo "${1}1")"
      sudo partprobe "$1" || true
      sudo udevadm settle || true

      sudo mkfs.exfat -n "$2" "$partition"

      echo "Drive $1 formatted as exFAT and labeled '$2'."
    fi
  fi
}

# =====================
# Media Transcoding
# =====================
transcode-video-1080p() {
  ffmpeg -i $1 -vf scale=1920:1080 -c:v libx264 -preset fast -crf 23 -c:a copy ${1%.*}-1080p.mp4
}

transcode-video-4K() {
  ffmpeg -i $1 -c:v libx265 -preset slow -crf 24 -c:a aac -b:a 192k ${1%.*}-optimized.mp4
}

img2jpg() {
  img="$1"
  shift
  magick "$img" $@ -quality 95 -strip ${img%.*}-optimized.jpg
}

img2jpg-small() {
  img="$1"
  shift
  magick "$img" $@ -resize 1080x\> -quality 95 -strip ${img%.*}-optimized.jpg
}

img2png() {
  img="$1"
  shift
  magick "$img" $@ -strip -define png:compression-filter=5 \
    -define png:compression-level=9 \
    -define png:compression-strategy=1 \
    -define png:exclude-chunk=all \
    "${img%.*}-optimized.png"
}

# =====================
# APT & Package Management
# =====================
apt-fzf() {
  if ! command -v fzf >/dev/null; then
    echo "fzf is not installed. Please install it first."
    return 1
  fi
  if ! command -v apt-cache >/dev/null; then
    echo "apt-cache is not available. This function requires apt."
    return 1
  fi
  local pkg
  # Get list of installed packages
  local installed_pkgs
  installed_pkgs=$(apt list --installed 2>/dev/null | awk -F/ 'NR>1{print $1}')
  # Mark installed packages with an asterisk
  pkg=$(apt-cache search . | awk '{print $1}' | sort | uniq | awk -v pkgs="$installed_pkgs" 'BEGIN{split(pkgs,arr,"\n");for(i in arr)inst[arr[i]]=1} {if(inst[$1]) print "* "$1; else print "  "$1}' | \
    fzf --prompt="APT package> " --ansi | sed 's/^\* //;s/^  //')
  if [ -n "$pkg" ]; then
    sudo apt install "$pkg"
  fi
}

apt-fzf-purge() {
  if ! command -v fzf >/dev/null; then
    echo "fzf is not installed. Please install it first."
    return 1
  fi
  if ! command -v apt >/dev/null; then
    echo "apt is not available. This function requires apt."
    return 1
  fi
  local pkg
  pkg=$(apt list --installed 2>/dev/null | awk -F/ 'NR>1{print $1}' | sort | uniq | fzf --prompt="Purge installed APT package> ")
  if [ -n "$pkg" ]; then
    sudo apt purge "$pkg"
    sudo apt autoclean
    sudo apt autoremove
    sudo apt autopurge
  fi
}

# =====================
# Shell & History Utilities
# =====================
zd() {
  if [ $# -eq 0 ]; then
    builtin cd ~ && return
  elif [ -d "$1" ]; then
    builtin cd "$1"
  else
    z "$@" && printf "\U000F17A9 " && pwd || echo "Error: Directory not found"
  fi
}
__fzf_history__() {
  local selected
  selected=$(history | awk '{sub(/^[ \t]*[0-9]+[ \t]*/, ""); if (!seen[$0]++) print}' | fzf --tac --preview 'echo {}' | sed 's/ *[0-9]* *//')
  if [ -n "$selected" ]; then
    READLINE_LINE="$selected"
    READLINE_POINT=${#READLINE_LINE}
  fi
}
bind -x '"\C-r": __fzf_history__'

